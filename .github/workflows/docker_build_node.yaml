
name: docker-build-node

on:
  workflow_call:
    inputs:
      working-directory:
        required: false
        type: string
        default: .
      node-version:
        required: false
        type: string
        default: '20'
      package-manager:
        required: false
        type: string
        default: 'npm'      # npm | yarn | pnpm (tu proyecto usa npm)
      acr-repository:
        required: true
        type: string        # repo en ACR, p.ej. myapp-node
    secrets:
      REGISTRY_USERNAME:
        required: true
      REGISTRY_PASSWORD:
        required: true
      KUBE_CONFIG:
        required: true

env:
  # Publicación opcional a GHCR (puedes quitar estas 3 variables si no lo usarás)
  REGISTRY: ghcr.io
  IMAGE_NAME: developer1-servitekconsulting/ms-tipo-de-cambio
  IMAGE_TAG: 1.0.${{ github.run_number }}

jobs:
  ci:
    name: Smoke Test (Node)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node-version }}
          cache: ${{ inputs.package-manager }}
          cache-dependency-path: |
            ${{ inputs.working-directory }}/package-lock.json
            ${{ inputs.working-directory }}/pnpm-lock.yaml
            ${{ inputs.working-directory }}/yarn.lock

      - name: Install deps (prod)
        working-directory: ${{ inputs.working-directory }}
        run: |
          if [ "${{ inputs.package-manager }}" = "npm" ]; then
            npm ci --omit=dev || npm install --production
          elif [ "${{ inputs.package-manager }}" = "yarn" ]; then
            yarn install --frozen-lockfile --production=true
          else
            npm i -g pnpm
            pnpm i --prod --frozen-lockfile
          fi

  build-push-docker:

    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Debug paths
        shell: bash
        run: |
          echo "WORKDIR=${{ inputs.working-directory }}"
          ls -la "${{ inputs.working-directory }}" || true
          test -f "${{ inputs.working-directory }}/Dockerfile" && echo "Dockerfile OK" || (echo "::error::No se encontró Dockerfile en ${{ inputs.working-directory }}" && exit 1)
      # Install the cosign tool except on PR
      # https://github.com/sigstore/cosign-installer
      - name: Install cosign
        if: github.event_name != 'pull_request'
        #uses: sigstore/cosign-installer@1e95c1de343b5b0c23352d6417ee3e48d5bcd422
        uses: sigstore/cosign-installer@v4.0.0
        with:
          cosign-release: 'v3.0.2'


      # Workaround: https://github.com/docker/build-push-action/issues/461
      - name: Setup Docker buildx
        uses: docker/setup-buildx-action@v3.11.1

      # Login against a Docker registry except on PR
      # https://github.com/docker/login-action
      - name: Log into registry ${{ env.REGISTRY }}
        if: github.event_name != 'pull_request'
        #uses: docker/login-action@v1
        uses: docker/login-action@v3.4.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Extract metadata (tags, labels) for Docker
      # https://github.com/docker/metadata-action
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5.7.0
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}

      # Build and push Docker image with Buildx (don't push on PR)
      # https://github.com/docker/build-push-action
      - name: Build and push Docker image
        id: build-and-push
        #uses: docker/build-push-action@v2
        uses: docker/build-push-action@v6.18.0
        with:
          context: ${{ inputs.working-directory }}
          file: ${{ inputs.working-directory }}/Dockerfile     # << ruta explícita del Dockerfile
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} # ${{ steps.meta.outputs.tags }}
          # tags: ghcr.io/houssemdellai/github-actions-course:${{ env.IMAGE_TAG }} # ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      # Sign the resulting Docker image digest except on PRs.
      # This will only write to the public Rekor transparency log when the Docker
      # repository is public to avoid leaking data.  If you would like to publish
      # transparency data even for private images, pass --force to cosign below.
      # https://github.com/sigstore/cosign
      - name: Sign the published Docker image
        if: ${{ github.event_name != 'pull_request' }}
        env:
          COSIGN_EXPERIMENTAL: "true"
        # This step uses the identity token to provision an ephemeral certificate
        # against the sigstore community Fulcio instance.
        run: cosign sign ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build-and-push.outputs.digest }}


      # --- Build & Push a ACR con usuario/contraseña ---
      - name: Docker login to ACR
        uses: azure/docker-login@v1
        with:
          login-server: tesiscloud.azurecr.io
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Build and Push image to ACR
        run: |
          IMAGE_REGISTRY=tesiscloud.azurecr.io
          IMAGE_REPO="${{ inputs.acr-repository }}"
          IMAGE_NAME=$IMAGE_REGISTRY/$IMAGE_REPO

          GIT_TAG=${{ github.sha }}
          VERSION=1.0.0

          docker build . -t $IMAGE_NAME:$VERSION -t $IMAGE_NAME:$GIT_TAG -t $IMAGE_NAME:latest
          docker push $IMAGE_NAME:$VERSION
          docker push $IMAGE_NAME:$GIT_TAG
          docker push $IMAGE_NAME:latest

  # --- Usar kubeconfig desde secreto (SIN azure/login) ---
      - name: Write kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
        # Export opcional: kubectl ya descubre ~/.kube/config
        env:
          KUBECONFIG: $HOME/.kube/config

      # Desplegar en AKS (sin imagePullSecret)
      - name: Deploy to AKS
        uses: Azure/k8s-deploy@v1
        with:
          namespace: default
          manifests: |
            k8s/deployment.yml
            k8s/service.yml
          #images: 'tesiscloud.azurecr.io/myapp-java:${{ github.sha }}'
          images: "tesiscloud.azurecr.io/${{ inputs.acr-repository }}:${{ github.sha }}"
          kubeconfig: ${{ secrets.KUBE_CONFIG }}
          action: deploy
