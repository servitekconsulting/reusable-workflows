name: Promote RC to GA

on:
  workflow_call:
    inputs:
      rc_version:
        description: "RC version, ej: v1.2.3-rc.2"
        required: true
        type: string
      image-name:
        description: "Nombre base de imagen, ej: myapp-java"
        required: true
        type: string
      publish_latest:
        description: "Etiquetar también como :latest"
        required: false
        type: boolean
        default: true
      do_ghcr:
        description: "Promocionar en GHCR"
        required: false
        type: boolean
        default: true
      do_acr:
        description: "Promocionar en ACR"
        required: false
        type: boolean
        default: true

      # ---- Controles de seguridad ----
      prod_branch:
        description: "Rama exacta desde la que se permite promover (ej: main). Dejar vacío si usarás patrón."
        required: false
        type: string
        default: ""
      prod_branch_pattern:
        description: "Patrón de rama permitido (glob). Ej: 'release/*'"
        required: false
        type: string
        default: "release/*"
      allow_tags:
        description: "Permitir ejecución si el ref es un tag"
        required: false
        type: boolean
        default: true

      protected_env_name:
        description: "Ambiente protegido (para aprobación). Usualmente 'prod'"
        required: false
        type: string
        default: "prod"
      require_org_member:
        description: "Exigir que el actor sea miembro de la organización"
        required: false
        type: boolean
        default: true
      allowed_actors:
        description: "Usuarios permitidos (coma-separado). Ej: 'alice,bob'"
        required: false
        type: string
        default: ""
      allowed_teams:
        description: "Equipos permitidos (coma-separado). Formato 'team-slug' o 'org/team-slug'"
        required: false
        type: string
        default: ""

    secrets:
      # Requeridos sólo si do_acr=true
      REGISTRY_USERNAME:
        required: false
      REGISTRY_PASSWORD:
        required: false

permissions:
  contents: write   # crear/editar releases y tags
  packages: write   # re-etiquetar imágenes en GHCR

jobs:
  promote:
    environment:
      name: ${{ inputs.protected_env_name }}   # Ej: prod (aplicará Protection rules)
    runs-on: ubuntu-latest

    outputs:
      ga_version: ${{ steps.compute.outputs.ga_version }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 1) Validación RC y cálculo de GA
      - name: Validate RC and compute GA
        id: compute
        shell: bash
        run: |
          RC="${{ inputs.rc_version }}"
          if ! echo "$RC" | grep -Eq '^v[0-9]+\.[0-9]+\.[0-9]+-rc\.[0-9]+$'; then
            echo "::error::'$RC' no es un RC válido (esperado vX.Y.Z-rc.N)"
            exit 1
          fi
          GA="$(echo "$RC" | sed -E 's/-rc\.[0-9]+$//')"

          echo "RC_VERSION=$RC"  >> $GITHUB_ENV
          echo "GA_VERSION=$GA"  >> $GITHUB_ENV
          echo "ga_version=$GA"  >> $GITHUB_OUTPUT

      # 2) Políticas: rama / organización / usuarios / equipos
      - name: Enforce branch & actor policy
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e

          REF_FULL="${GITHUB_REF}"             # ej: refs/heads/release/v0.1.0 o refs/tags/v0.1.0-rc.2
          REF_TYPE="${GITHUB_REF##refs/}"      # heads/release/v0.1.0  o tags/v0.1.0-rc.2
          REF_NAME="${GITHUB_REF_NAME}"        # release/v0.1.0        o v0.1.0-rc.2

          PROD_BRANCH="${{ inputs.prod_branch }}"
          PROD_PATTERN="${{ inputs.prod_branch_pattern }}"
          ALLOW_TAGS="${{ inputs.allow_tags }}"

          echo "Ref completo: $REF_FULL"
          echo "Tipo: $REF_TYPE"
          echo "Nombre: $REF_NAME"
          echo "Reglas: prod_branch='$PROD_BRANCH', prod_branch_pattern='$PROD_PATTERN', allow_tags=$ALLOW_TAGS"

          # 1) Si ref es tag y allow_tags=true -> OK
          if [ "${REF_TYPE%%/*}" = "tags" ] && [ "$ALLOW_TAGS" = "true" ]; then
            echo "Ref es un TAG y allow_tags=true -> OK"
          else
            # 2) Si hay rama exacta definida y coincide -> OK
            if [ -n "$PROD_BRANCH" ] && [ "$REF_NAME" = "$PROD_BRANCH" ]; then
              echo "Rama exacta '$PROD_BRANCH' permitida -> OK"
            else
              # 3) Si hay patrón definido y coincide -> OK
              if [ -n "$PROD_PATTERN" ]; then
                # Implementa glob simple: 'release/*'
                PATTERN_PREFIX="${PROD_PATTERN%%\*}"   # parte antes del asterisco
                if [ -n "$PATTERN_PREFIX" ] && [[ "$REF_NAME" == $PATTERN_PREFIX* ]]; then
                  echo "Rama '$REF_NAME' coincide con patrón '$PROD_PATTERN' -> OK"
                else
                  echo "::error::Este job solo puede ejecutarse desde una rama que cumpla el patrón '$PROD_PATTERN' o la rama exacta '$PROD_BRANCH', o desde TAG (allow_tags=$ALLOW_TAGS). Ref actual: '$REF_NAME'"
                  exit 1
                fi
              else
                echo "::error::No se definió ni 'prod_branch' ni 'prod_branch_pattern', y el ref no es TAG permitido. Ref actual: '$REF_NAME'"
                exit 1
              fi
            fi
          fi

          # Miembro de la organización (si aplica) — usar memberships (funciona con miembros privados)
          if [ "${{ inputs.require_org_member }}" = "true" ]; then
            ORG="${{ github.repository_owner }}"
            # Consulta la membresía (privada o pública). Esperamos state=active.
            STATUS_JSON="$(gh api -X GET "orgs/$ORG/memberships/${{ github.actor }}" 2>/dev/null || true)"
            if [ -z "$STATUS_JSON" ]; then
              echo "::error::No se pudo consultar la membresía del actor '${{ github.actor }}' en la organización '$ORG'."
              exit 1
            fi
            # Extrae 'state' con jq (instalado por defecto en runners de Ubuntu)
            STATE="$(echo "$STATUS_JSON" | jq -r '.state // empty')"
            if [ "$STATE" != "active" ]; then
              echo "::error::El actor '${{ github.actor }}' no tiene membresía activa en '$ORG' (state='$STATE')."
              exit 1
            fi
          fi

          # Alternativa/fallback: permisos en el repo (push/maintain/admin)
          PERM_JSON="$(gh api repos/${{ github.repository }}/collaborators/${{ github.actor }}/permission 2>/dev/null || true)"
          PERM="$(echo "$PERM_JSON" | jq -r '.permission // empty')"
          case "$PERM" in
            admin|maintain|push)
              echo "Permiso en repo suficiente: $PERM -> OK"
              ;;
            *)
              # Si no cumple repo-permission, y require_org_member=false, aún podemos permitir por allowed lists
              if [ "${{ inputs.require_org_member }}" = "false" ]; then
                echo "Permiso repo: '$PERM'. Se permitirá continuar si pasa allowed_actors/allowed_teams."
              else
                echo "::error::Permiso insuficiente en repo: '$PERM' (se requiere admin/maintain/push)."
                exit 1
              fi
              ;;
          esac

          # Lista blanca de usuarios (si provista)
          ALLOWED="${{ inputs.allowed_actors }}"
          if [ -n "$ALLOWED" ]; then
            IFS=',' read -ra LIST <<< "$ALLOWED"
            OK="false"
            for u in "${LIST[@]}"; do
              u_trim="$(echo "$u" | xargs)"
              if [ "$u_trim" = "${{ github.actor }}" ]; then OK="true"; break; fi
            done
            if [ "$OK" != "true" ]; then
              echo "::error::Usuario '${{ github.actor }}' no está en allowed_actors: $ALLOWED"
              exit 1
            fi
          fi

          # Pertenencia a equipos (si provistos)
          TEAMS="${{ inputs.allowed_teams }}"
          if [ -n "$TEAMS" ]; then
            IFS=',' read -ra TLIST <<< "$TEAMS"
            IN_TEAM="false"
            for t in "${TLIST[@]}"; do
              t_trim="$(echo "$t" | xargs)"
              team_slug="$t_trim"
              ORG="${{ github.repository_owner }}"
              if echo "$t_trim" | grep -q '/'; then
                 ORG="${t_trim%%/*}"
                 team_slug="${t_trim##*/}"
              fi
              if gh api -X GET "orgs/$ORG/teams/$team_slug/memberships/${{ github.actor }}" >/dev/null 2>&1; then
                IN_TEAM="true"; break
              fi
            done
            if [ "$IN_TEAM" != "true" ]; then
              echo "::error::Usuario '${{ github.actor }}' no pertenece a ninguno de los equipos permitidos: $TEAMS"
              exit 1
            fi
          fi

          echo "Políticas de branch/actor verificadas ✅"

      # 3) Verifica que GA no exista
      - name: Ensure GA does not exist yet
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -e
          git fetch --tags --quiet
          if git rev-parse -q --verify "refs/tags/$GA_VERSION" >/dev/null; then
            echo "::error::Tag GA '$GA_VERSION' ya existe"
            exit 1
          fi
          if gh release view "$GA_VERSION" >/dev/null 2>&1; then
            echo "::error::Release GA '$GA_VERSION' ya existe"
            exit 1
          fi

      # 4) Promoción de imágenes
      - name: Setup buildx (for imagetools)
        uses: docker/setup-buildx-action@v3

      ## GHCR
      - name: Login GHCR
        if: ${{ inputs.do_ghcr }}
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Promote image in GHCR (RC -> GA)
        if: ${{ inputs.do_ghcr }}
        shell: bash
        run: |
          OWNER_LOWER="$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')"
          IMAGE_LOWER="$(echo "${{ inputs.image-name }}" | tr '[:upper:]' '[:lower:]')"
          SRC="ghcr.io/${OWNER_LOWER}/${IMAGE_LOWER}:${RC_VERSION}"
          DST_GA="ghcr.io/${OWNER_LOWER}/${IMAGE_LOWER}:${GA_VERSION}"

          echo "Promoviendo GHCR: $SRC -> $DST_GA"
          docker buildx imagetools create -t "$DST_GA" "$SRC"

          if [ "${{ inputs.publish_latest }}" = "true" ]; then
            DST_LATEST="ghcr.io/${OWNER_LOWER}/${IMAGE_LOWER}:latest"
            echo "Adicional: GHCR -> $DST_LATEST"
            docker buildx imagetools create -t "$DST_LATEST" "$SRC"
          fi

      ## ACR
      - name: Login ACR
        if: ${{ inputs.do_acr }}
        uses: azure/docker-login@v1
        with:
          login-server: tesiscloud.azurecr.io
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Promote image in ACR (RC -> GA)
        if: ${{ inputs.do_acr }}
        shell: bash
        run: |
          IMAGE_LOWER="$(echo "${{ inputs.image-name }}" | tr '[:upper:]' '[:lower:]')"
          SRC="tesiscloud.azurecr.io/${IMAGE_LOWER}:${RC_VERSION}"
          DST_GA="tesiscloud.azurecr.io/${IMAGE_LOWER}:${GA_VERSION}"

          echo "Promoviendo ACR: $SRC -> $DST_GA"
          docker buildx imagetools create -t "$DST_GA" "$SRC"

          if [ "${{ inputs.publish_latest }}" = "true" ]; then
            DST_LATEST="tesiscloud.azurecr.io/${IMAGE_LOWER}:latest"
            echo "Adicional: ACR -> $DST_LATEST"
            docker buildx imagetools create -t "$DST_LATEST" "$SRC"
          fi

      # 5) Crear Release GA (gh crea el tag automáticamente)
      - name: Create GA Release (gh creates tag)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create "$GA_VERSION" \
            --title "Release $GA_VERSION" \
            --latest \
            --generate-notes

      - name: Summary
        run: |
          echo "### Promoción completada" >> $GITHUB_STEP_SUMMARY
          echo "- RC: \`$RC_VERSION\`" >> $GITHUB_STEP_SUMMARY
          echo "- GA: \`$GA_VERSION\`"   >> $GITHUB_STEP_SUMMARY
