name: Build and Deploy

on:
  workflow_call:
    inputs:
      working-directory:
        required: false
        type: string
        default: .           # ← raíz por defecto
      image-name:
        required: true
        type: string
      environment:
        required: true
        type: string

    secrets:
      REGISTRY_USERNAME:
        required: true      # Usuario del ACR (admin o SP con AcrPush)
      REGISTRY_PASSWORD:
        required: true      # Password/secret del ACR
      KUBE_CONFIG:
        required: true      # Contenido del kubeconfig del AKS (texto completo)

env:
  # Use docker.io for Docker Hub if empty
  REGISTRY: ghcr.io
  # github.repository as <account>/<repo>
  IMAGE_NAME: developer1-servitekconsulting/api-tesis-prueba
  IMAGE_TAG: 1.0.${{ github.run_number }} # GITHUB_RUN_NUMBER }}

jobs:
  build_deploy:
    environment:
      name: ${{ github.event_name != 'pull_request' && inputs.environment || ''}}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      # This is used to complete the identity challenge
      # with sigstore/fulcio when running outside of PRs.
      id-token: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Debug paths
        shell: bash
        run: |
          echo "WORKDIR=${{ inputs.working-directory }}"
          ls -la "${{ inputs.working-directory }}" || true
          test -f "${{ inputs.working-directory }}/Dockerfile" && echo "Dockerfile OK" || (echo "::error::No se encontró Dockerfile en ${{ inputs.working-directory }}" && exit 1)
      # Install the cosign tool except on PR
      # https://github.com/sigstore/cosign-installer
      - name: Install cosign
        if: github.event_name != 'pull_request'
        #uses: sigstore/cosign-installer@1e95c1de343b5b0c23352d6417ee3e48d5bcd422
        uses: sigstore/cosign-installer@v4.0.0
        with:
          cosign-release: 'v3.0.2'


      # Workaround: https://github.com/docker/build-push-action/issues/461
      - name: Setup Docker buildx
        #uses: docker/setup-buildx-action@v1
        uses: docker/setup-buildx-action@v3.11.1

      # Login against a Docker registry except on PR
      # https://github.com/docker/login-action
      - name: Log into registry ${{ env.REGISTRY }}
        if: github.event_name != 'pull_request'
        #uses: docker/login-action@v1
        uses: docker/login-action@v3.4.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Extract metadata (tags, labels) for Docker
      # https://github.com/docker/metadata-action
      - name: Extract Docker metadata
        id: meta
        #uses: docker/metadata-action@v1
        uses: docker/metadata-action@v5.7.0
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}

      # Build and push Docker image with Buildx (don't push on PR)
      # https://github.com/docker/build-push-action
      - name: Build and push Docker image
        id: build-and-push
        #uses: docker/build-push-action@v2
        uses: docker/build-push-action@v6.18.0
        with:
          context: ${{ inputs.working-directory }}
          file: ${{ inputs.working-directory }}/Dockerfile     # << ruta explícita del Dockerfile
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} # ${{ steps.meta.outputs.tags }}
          # tags: ghcr.io/houssemdellai/github-actions-course:${{ env.IMAGE_TAG }} # ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      # Sign the resulting Docker image digest except on PRs.
      # This will only write to the public Rekor transparency log when the Docker
      # repository is public to avoid leaking data.  If you would like to publish
      # transparency data even for private images, pass --force to cosign below.
      # https://github.com/sigstore/cosign
      - name: Sign the published Docker image
        if: ${{ github.event_name != 'pull_request' }}
        env:
          COSIGN_EXPERIMENTAL: "true"
        # This step uses the identity token to provision an ephemeral certificate
        # against the sigstore community Fulcio instance.
        run: cosign sign ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build-and-push.outputs.digest }}


      # --- Build & Push a ACR con usuario/contraseña ---
      - name: Docker login to ACR
        uses: azure/docker-login@v1
        with:
          login-server: tesiscloud.azurecr.io
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Build and Push image to ACR
        run: |
          IMAGE_REGISTRY=tesiscloud.azurecr.io
          IMAGE_REPO=myapp-java
          IMAGE_NAME=$IMAGE_REGISTRY/$IMAGE_REPO

          GIT_TAG=${{ github.sha }}
          VERSION=1.0.0

          docker build . -t $IMAGE_NAME:$VERSION -t $IMAGE_NAME:$GIT_TAG -t $IMAGE_NAME:latest
          docker push $IMAGE_NAME:$VERSION
          docker push $IMAGE_NAME:$GIT_TAG
          docker push $IMAGE_NAME:latest

  # --- Usar kubeconfig desde secreto (SIN azure/login) ---
      - name: Write kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
        # Export opcional: kubectl ya descubre ~/.kube/config
        env:
          KUBECONFIG: $HOME/.kube/config

      # Desplegar en AKS (sin imagePullSecret)
      - name: Deploy to AKS
        uses: Azure/k8s-deploy@v1
        with:
          namespace: default
          manifests: |
            k8s/deployment.yml
            k8s/service.yml
          images: 'tesiscloud.azurecr.io/myapp-java:${{ github.sha }}'
          kubeconfig: ${{ secrets.KUBE_CONFIG }}
          action: deploy